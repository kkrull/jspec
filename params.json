{"name":"Javaspec","tagline":"Spec-style testing for Java","body":"# JavaSpec\r\n\r\nBehavior-Driven Development testing for Java using lambdas.  Inspired by [RSpec](http://rspec.info) and\r\n[Machine.Specifications](https://github.com/machine/machine.specifications).\r\n\r\nBuild status\r\n\r\n- `master` [![Build Status](https://travis-ci.org/kkrull/javaspec.svg?branch=master)](https://travis-ci.org/kkrull/javaspec)\r\n- `develop` [![Build Status](https://travis-ci.org/kkrull/javaspec.svg?branch=develop)](https://travis-ci.org/kkrull/javaspec)\r\n\r\n## Why\r\n\r\n*Why create another testing framework for Java, and why use lambdas?*\r\n\r\nJavaSpec attempts to be:\r\n\r\n- **Concise**: Simple behavior should be simple to test and describe in a small amount of space.\r\n- **Searchable**: Finding call sites in Java code is easy.  Finding where a test calls your code should be just as easy.\r\n- **Transparent**: You shouldn't have to keep any caveats in mind when writing test code.\r\n\r\nThere are many testing libraries out there with some of these characteristics, but expresiveness does not need to come\r\nat the cost of adding complexity.  For example you can write your tests in Ruby or Groovy (as the author once\r\nconsidered), but now you're adding more components between your test and production code, adding new dependencies, and\r\nlosing out on searchability.\r\n\r\nLambdas are the weapon of choice for turning simple expressions into one-liners.  A test with one assertion can be 1\r\nline instead of several for tagging and creating whole, new test method.\r\n\r\n## Installation\r\n\r\nJavaSpec is located in the Maven Central Repository, under the following coordinates:\r\n\r\n```\r\n<dependency>\r\n  <groupId>info.javaspec</groupId>\r\n  <artifactId>javaspec-runner</artifactId>\r\n  <version>1.0.1</version>\r\n</dependency>\r\n```\r\n\r\nIt depends upon JUnit and Java 8+.\r\n\r\n\r\n# Getting started\r\n\r\nThere's no magic in how JavaSpec works.  This guide describes JavaSpec in terms of its similarities to popular libraries\r\ninstead of pretending like these are radical, never-before-seen ideas.\r\n\r\n## It runs on JUnit\r\n\r\nIn JUnit, you create a test class and put `@Test` methods in it.  JavaSpec is similar:\r\n\r\n- Make a test class.\r\n- Tag it with `@RunWith(JavaSpecRunner.class)`.\r\n- Include 1 or more `It` fields in the class and assign a no-arg lambda to it.  Put whatever code you would normally run\r\n  in the `@Test` method in this lambda.\r\n- Run your tests anywhere you run JUnit.  Maven (surefire plugin) and Eclipse Luna work.\r\n\r\nA simple \"Hello World\" test looks like this:\r\n\r\n```java\r\n@RunWith(JavaSpecRunner.class)\r\nclass GreeterTest {\r\n  It says_hello = () -> assertEquals(\"Hello World!\", new Greeter().sayHello());\r\n}\r\n```\r\n\r\nAs with JUnit, you get 1 instance of your test class per test.  Each `It` is its own test.\r\n\r\nFinally, note that the `It` field is named `says_hello` instead of the conventional `saysHello`.  This is done so that\r\nJavaSpec can convert that verb phrase into a human readable form by replacing underscores with spaces.  When you run\r\nthis test, JUnit will report results for `says hello`.\r\n\r\n## It's like Machine.Specifications\r\n\r\nMachine.Specifications and JavaSpec represent the different steps of a test the same way:\r\n\r\n- An `Establish` lambda runs the Arrange part of your test.  This runs first, when present.\r\n- A `Because` lambda runs the Act part of your test.  This runs next, when present.\r\n- An `It` lambda does the Assert part of your test.\r\n- A `Cleanup` lambda - when present - always runs, even if a prior step failed.\r\n- If any step throws an exception, the test fails.\r\n\r\nYou can think of `Establish` and `Because` as what a `@Before` method would do in JUnit.  These lambdas run before each\r\n`It` lambda in the same class (and also before `It` fields in inner classes).  `Cleanup` is like `@After` in JUnit,\r\nrunning after each `It` in the same test class.\r\n\r\nUnlike MSpec, your lambdas execute in an *instance* of the class in which they are declared.  Non-static helper methods\r\nin your test class are fair game to be called from any step.\r\n\r\nA JavaSpec test fixture looks like this:\r\n\r\n```java\r\n@RunWith(JavaSpecRunner.class)\r\nclass GreeterWithFixtureTest {\r\n  private final PrintStreamSpy printStreamSpy = new PrintStreamSpy();\r\n  private Widget subject;\r\n  private String returned;\r\n\r\n  Establish that = () -> subject = new Widget(printStreamSpy);\r\n  Because of = () -> returned = subject.foo();\r\n  Cleanup close_streams = () -> {\r\n    if(subject != null)\r\n      subject.close();\r\n  };\r\n\r\n  It returns_bar = () -> assertEquals(\"bar\", returned);\r\n  It prints_baz = () -> assertEquals(\"baz\", printStreamSpy.getWhatWasPrinted());\r\n}\r\n```\r\n\r\n## It's like RSpec\r\n\r\nRSpec lets you organize hierarchies of tests and fixtures with `describe` and `context`, and each level in the tree can\r\nhave its own `before` and `after` methods to work the test fixture.  JavaSpec provides nested contexts by nesting\r\n*context classes* (inner, **non-static** classes) in the top-level test class.\r\n\r\nEach class can have as many `It` lambdas as you want, plus up to 1 of each type of fixture lambda (`Establish`,\r\n`Because`, and `Cleanup`) to build up the test fixture.  As with RSpec, setup runs outside-in and cleanup runs\r\ninside-out.  If you happen to have an `Because` in an outer class and an `Establish` in an inner class and wonder which\r\none runs first, the outer class lambdas run first (i.e. `Because` runs first).\r\n\r\nAn example of using nested contexts:\r\n\r\n```java\r\n@RunWith(JavaSpecRunner.class)\r\nclass WidgetTest {\r\n  private Widget subject;\r\n  Establish that = () -> subject = new Widget();\r\n\r\n  class foo {\r\n    private String returned;\r\n    Because of = () -> returned = subject.sayHello();\r\n    It says_hello = () -> assertEquals(\"Hello World!\", returned);\r\n  }\r\n  \r\n  class bar {\r\n    class given_a_multiple_of_3 {\r\n      It prints_fizz = () -> assertEquals(\"fizz\", subject.bar(3));\r\n    }\r\n\r\n    class given_a_multiple_of_5 {\r\n      It prints_buzz = () -> assertEquals(\"buzz\", subject.bar(5));\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nIn short:\r\n\r\n- Only tag the outer-most class with `@RunWith(JavaSpecRunner.class)`.  Don't tag any inner classes with this.\r\n- Make as many contexts as you like by making nested, non-static classes.\r\n- Add up to 1 each of `Establish`, `Because` and `Cleanup` to each context class.\r\n- Make as many tests as you want in each context class with `It` lambdas.\r\n\r\n## If you have any other questions\r\n\r\nHopefully JavaSpec works like you think it does.\r\n\r\nFor times when it doesn't, start by looking at the tests on\r\n[`JavaSpecRunner`](https://github.com/kkrull/javaspec/blob/master/src/test/java/info/javaspec/runner/JavaSpecRunnerTest.java)\r\nand related classes.\r\n\r\nIf that still doesn't do the trick, feel [post an issue](https://github.com/kkrull/javaspec/issues) or submit a pull\r\nrequest with any suggested modifications.\r\n\r\n# Future work\r\n\r\n- Ability to `@Ignore` a class or an `It`.  Better yet, `@Focus` on one, pesky test.\r\n- Use strings instead of identifiers to allow a more natural language for describing behavior.\r\n- Something similar to RSpec's `shared_examples` and `shared_context` could be useful.\r\n\r\n# Release history\r\n\r\n- 1.0.1: Fixed [Issue 5](https://github.com/kkrull/javaspec/issues/5), catching some errors in initializing test classes.\r\n- 1.0: Full release.  Renamed artifact to `info.javaspec::javaspec-runner`.\r\n- 0.5: Fixed an issue where specs with the same field / context class name were showing up as still running in IntelliJ.\r\n  Also renamed JUnit test display names to human-readable names, replacing snake case underscores with spaces.\r\n- 0.4.2: Fixed [Issue 2](https://github.com/kkrull/javaspec/issues/2), so that only one instance of a context class is\r\n  created for each test.\r\n- 0.4.1: Fixed [Issue 1](https://github.com/kkrull/javaspec/issues/1), dealing with being able to instantiate non-public\r\n  context classes.\r\n- 0.4.0: Initial release","google":"UA-54933252-1","note":"Don't delete this file! It's used internally to help with page regeneration."}