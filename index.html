<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Javaspec : Spec-style testing for Java">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Javaspec</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/kkrull/javaspec">View on GitHub</a>

          <h1 id="project_title">Javaspec</h1>
          <h2 id="project_tagline">Spec-style testing for Java</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/kkrull/javaspec/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/kkrull/javaspec/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="javaspec" class="anchor" href="#javaspec" aria-hidden="true"><span class="octicon octicon-link"></span></a>JavaSpec</h1>

<p>Spec-style testing for Java using lambdas.  Inspired by <a href="http://rspec.info">RSpec</a> and
<a href="https://github.com/machine/machine.specifications">Machine.Specifications</a>.</p>

<p><em>Why create another testing framework for Java, and why use lambdas?</em></p>

<p>JavaSpec attempts to be:</p>

<ul>
<li>
<strong>Concise</strong>: Simple behavior should be simple to test and describe in a small amount of space.</li>
<li>
<strong>Searchable</strong>: Finding call sites in Java code is easy.  Finding where a test calls your code should be just as easy.</li>
<li>
<strong>Transparent</strong>: You shouldn't have to keep any caveats in mind when writing test code.</li>
</ul>

<p>There are many testing libraries out there with some of these characteristics, but expresiveness does not need to come
at the cost of adding complexity.  For example you can write your tests in Ruby or Groovy (as the author once
considered), but now you're adding more components between your test and production code, adding new dependencies, and
losing out on searchability.</p>

<p>Lambdas are the weapon of choice for turning simple expressions into one-liners.  A test with one assertion can be 1
line instead of several for tagging and creating whole, new test method.</p>

<h2>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installation</h2>

<p>JavaSpec is located in the Maven Central Repository, under the following coordinates:</p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;info.javaspec&lt;/groupId&gt;
  &lt;artifactId&gt;javaspec&lt;/artifactId&gt;
  &lt;version&gt;0.4.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>It depends upon JUnit and Java 8+.</p>

<h1>
<a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"><span class="octicon octicon-link"></span></a>Getting started</h1>

<p>There's no magic in how JavaSpec works.  This guide describes JavaSpec in terms of its similarities to popular libraries
instead of pretending like these are radical, never-before-seen ideas.</p>

<h2>
<a id="it-runs-on-junit" class="anchor" href="#it-runs-on-junit" aria-hidden="true"><span class="octicon octicon-link"></span></a>It runs on JUnit</h2>

<p>In JUnit, you create a test class and put <code>@Test</code> methods in it.  JavaSpec is similar:</p>

<ul>
<li>Make a test class.</li>
<li>Tag it with <code>@RunWith(JavaSpecRunner.class)</code>.</li>
<li>Include 1 or more <code>It</code> fields in the class and assign a no-arg lambda to it.  Put whatever code you would normally run
in the <code>@Test</code> method in this lambda.</li>
<li>Run your tests anywhere you run JUnit.  Maven (surefire plugin) and Eclipse Luna work.</li>
</ul>

<p>A simple "Hello World" test looks like this:</p>

<div class="highlight highlight-java"><pre>@RunWith(<span class="pl-stj">JavaSpecRunner</span><span class="pl-k">.</span>class)
<span class="pl-s">class</span> <span class="pl-en">GreeterTest</span> {
  <span class="pl-stj">It</span> says_hello <span class="pl-k">=</span> () <span class="pl-k">-</span><span class="pl-k">&gt;</span> assertEquals(<span class="pl-s1"><span class="pl-pds">"</span>Hello World!<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> <span class="pl-stj">Greeter</span>()<span class="pl-k">.</span>sayHello());
}</pre></div>

<p>As with JUnit, you get 1 instance of your test class per test.  Each <code>It</code> is its own test.</p>

<h2>
<a id="its-like-machinespecifications" class="anchor" href="#its-like-machinespecifications" aria-hidden="true"><span class="octicon octicon-link"></span></a>It's like Machine.Specifications</h2>

<p>Machine.Specifications and JavaSpec represent the different steps of a test the same way:</p>

<ul>
<li>An <code>Establish</code> lambda runs the Arrange part of your test.  This runs first, when present.</li>
<li>A <code>Because</code> lambda runs the Act part of your test.  This runs next, when present.</li>
<li>An <code>It</code> lambda does the Assert part of your test.</li>
<li>A <code>Cleanup</code> lambda - when present - always runs, even if a prior step failed.</li>
<li>If any step throws an exception, the test fails.</li>
</ul>

<p>You can think of <code>Establish</code> and <code>Because</code> as what a <code>@Before</code> method would do in JUnit.  These lambdas run before each
<code>It</code> lambda in the same class (and also before <code>It</code> fields in inner classes).  <code>Cleanup</code> is like <code>@After</code> in JUnit,
running after each <code>It</code> in the same test class.</p>

<p>Unlike MSpec, your lambdas execute in an <em>instance</em> of the class in which they are declared.  Non-static helper methods
in your test class are fair game to be called from any step.</p>

<p>A JavaSpec test fixture looks like this:</p>

<div class="highlight highlight-java"><pre>@RunWith(<span class="pl-stj">JavaSpecRunner</span><span class="pl-k">.</span>class)
<span class="pl-s">class</span> <span class="pl-en">GreeterWithFixtureTest</span> {
  <span class="pl-s">private</span> <span class="pl-s">final</span> <span class="pl-stj">PrintStreamSpy</span> printStreamSpy <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-stj">PrintStreamSpy</span>();
  <span class="pl-s">private</span> <span class="pl-stj">Widget</span> subject;
  <span class="pl-s">private</span> <span class="pl-stj">String</span> returned;

  <span class="pl-stj">Establish</span> that <span class="pl-k">=</span> () <span class="pl-k">-</span><span class="pl-k">&gt;</span> subject <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-stj">Widget</span>(printStreamSpy);
  <span class="pl-stj">Because</span> of <span class="pl-k">=</span> () <span class="pl-k">-</span><span class="pl-k">&gt;</span> returned <span class="pl-k">=</span> subject<span class="pl-k">.</span>foo();
  <span class="pl-stj">Cleanup</span> closeStreams <span class="pl-k">=</span> () <span class="pl-k">-</span><span class="pl-k">&gt;</span> {
    <span class="pl-k">if</span>(subject <span class="pl-k">!=</span> <span class="pl-c1">null</span>)
      subject<span class="pl-k">.</span>close();
  };

  <span class="pl-stj">It</span> returns_bar <span class="pl-k">=</span> () <span class="pl-k">-</span><span class="pl-k">&gt;</span> assertEquals(<span class="pl-s1"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>, returned);
  <span class="pl-stj">It</span> prints_baz <span class="pl-k">=</span> () <span class="pl-k">-</span><span class="pl-k">&gt;</span> assertEquals(<span class="pl-s1"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>, printStreamSpy<span class="pl-k">.</span>getWhatWasPrinted());
}</pre></div>

<h2>
<a id="its-like-rspec" class="anchor" href="#its-like-rspec" aria-hidden="true"><span class="octicon octicon-link"></span></a>It's like RSpec</h2>

<p>RSpec lets you organize hierarchies of tests and fixtures with <code>describe</code> and <code>context</code>, and each level in the tree can
have its own <code>before</code> and <code>after</code> methods to work the test fixture.  JavaSpec provides nested contexts by nesting
<em>context classes</em> (inner, <strong>non-static</strong> classes) in the top-level test class.</p>

<p>Each class can have as many <code>It</code> lambdas as you want, plus up to 1 of each type of fixture lambda (<code>Establish</code>,
<code>Because</code>, and <code>Cleanup</code>) to build up the test fixture.  As with RSpec, setup runs outside-in and cleanup runs
inside-out.  If you happen to have an <code>Because</code> in an outer class and an <code>Establish</code> in an inner class and wonder which
one runs first, the outer class lambdas run first (i.e. <code>Because</code> runs first).</p>

<p>An example of using nested contexts:</p>

<div class="highlight highlight-java"><pre>@RunWith(<span class="pl-stj">JavaSpecRunner</span><span class="pl-k">.</span>class)
<span class="pl-s">class</span> <span class="pl-en">WidgetTest</span> {
  <span class="pl-s">private</span> <span class="pl-stj">Widget</span> subject;
  <span class="pl-stj">Establish</span> that <span class="pl-k">=</span> () <span class="pl-k">-</span><span class="pl-k">&gt;</span> subject <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-stj">Widget</span>();

  <span class="pl-s">class</span> <span class="pl-en">foo</span> {
    <span class="pl-s">private</span> <span class="pl-stj">String</span> returned;
    <span class="pl-stj">Because</span> of <span class="pl-k">=</span> () <span class="pl-k">-</span><span class="pl-k">&gt;</span> returned <span class="pl-k">=</span> subject<span class="pl-k">.</span>sayHello();
    <span class="pl-stj">It</span> says_hello <span class="pl-k">=</span> () <span class="pl-k">-</span><span class="pl-k">&gt;</span> assertEquals(<span class="pl-s1"><span class="pl-pds">"</span>Hello World!<span class="pl-pds">"</span></span>, returned);
  }

  <span class="pl-s">class</span> <span class="pl-en">bar</span> {
    <span class="pl-s">class</span> <span class="pl-en">givenAMultipleOf3</span> {
      <span class="pl-stj">It</span> prints_fizz <span class="pl-k">=</span> () <span class="pl-k">-</span><span class="pl-k">&gt;</span> assertEquals(<span class="pl-s1"><span class="pl-pds">"</span>fizz<span class="pl-pds">"</span></span>, subject<span class="pl-k">.</span>bar(<span class="pl-c1">3</span>));
    }

    <span class="pl-s">class</span> <span class="pl-en">givenAMultipleOf5</span> {
      <span class="pl-stj">It</span> prints_buzz <span class="pl-k">=</span> () <span class="pl-k">-</span><span class="pl-k">&gt;</span> assertEquals(<span class="pl-s1"><span class="pl-pds">"</span>buzz<span class="pl-pds">"</span></span>, subject<span class="pl-k">.</span>bar(<span class="pl-c1">5</span>));
    }
  }
}</pre></div>

<p>In short:</p>

<ul>
<li>Only tag the outer-most class with <code>@RunWith(JavaSpecRunner.class)</code>.  Don't tag any inner classes with this.</li>
<li>Make as many contexts as you like by making nested, non-static classes.</li>
<li>Add up to 1 each of <code>Establish</code>, <code>Because</code> and <code>Cleanup</code> to each context class.</li>
<li>Make as many tests as you want in each context class with 0 or more <code>It</code> lambdas.</li>
</ul>

<h2>
<a id="if-you-have-any-other-questions" class="anchor" href="#if-you-have-any-other-questions" aria-hidden="true"><span class="octicon octicon-link"></span></a>If you have any other questions</h2>

<p>Hopefully JavaSpec works like you think it does  For times when it doesn't, start by looking at the tests on
<a href="https://github.com/kkrull/javaspec/blob/master/src/test/java/info/javaspec/runner/JavaSpecRunnerTest.java"><code>JavaSpecRunner</code></a>
and related classes.</p>

<h1>
<a id="future-work" class="anchor" href="#future-work" aria-hidden="true"><span class="octicon octicon-link"></span></a>Future work</h1>

<ul>
<li>Ability to <code>@Ignore</code> a class or an <code>It</code>.  Better yet, <code>@Focus</code> on one, pesky test.</li>
<li>JavaSpec can use strings to allow a more natural language for describing behavior.</li>
<li>Something similar to RSpec's <code>shared_examples</code> and <code>shared_context</code> could be useful.</li>
<li>Feel free to <a href="https://github.com/kkrull/javaspec/issues">add an issue in GitHub</a> if if JavaSpec's current behavior is
not clear or could be improved.</li>
</ul>

<h1>
<a id="release-history" class="anchor" href="#release-history" aria-hidden="true"><span class="octicon octicon-link"></span></a>Release history</h1>

<ul>
<li>0.4.2: Fixed <a href="https://github.com/kkrull/javaspec/issues/2">Issue 2</a>, so that only one instance of a context class is
created for each test.</li>
<li>0.4.1: Fixed <a href="https://github.com/kkrull/javaspec/issues/1">Issue 1</a>, dealing with being able to instantiate non-public
context classes.</li>
<li>0.4.0: Initial release</li>
</ul>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Javaspec maintained by <a href="https://github.com/kkrull">kkrull</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-54933252-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
